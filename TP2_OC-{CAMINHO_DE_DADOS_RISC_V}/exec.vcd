$date
	Sun Aug 11 22:11:29 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module Testbench $end
$var wire 32 ! saida_pc [31:0] $end
$var reg 1 " clk $end
$var reg 1 # reset $end
$scope module uut $end
$var wire 1 " clk $end
$var wire 1 # reset $end
$var wire 32 $ saida_pc [31:0] $end
$var wire 1 % zero $end
$var wire 32 & saida_Imm [31:0] $end
$var wire 32 ' pc_next [31:0] $end
$var wire 32 ( pc [31:0] $end
$var wire 32 ) mem_data [31:0] $end
$var wire 1 * branch $end
$var wire 32 + Resultado_ALU [31:0] $end
$var wire 32 , Register2 [31:0] $end
$var wire 32 - Register1 [31:0] $end
$var wire 1 . RegWrite $end
$var wire 1 / Mem_to_Reg $end
$var wire 1 0 Mem_Write $end
$var wire 1 1 Mem_Read $end
$var wire 32 2 Instrucao [31:0] $end
$var wire 3 3 ALUop [2:0] $end
$var wire 1 4 ALU_src $end
$scope module ALU $end
$var wire 32 5 Y [31:0] $end
$var wire 1 % zero $end
$var wire 32 6 X [31:0] $end
$var wire 3 7 ALUop [2:0] $end
$var reg 32 8 Resultado_ALU [31:0] $end
$upscope $end
$scope module Control $end
$var wire 3 9 funct3 [2:0] $end
$var wire 7 : funct7 [6:0] $end
$var wire 7 ; opcode [6:0] $end
$var reg 1 4 ALU_src $end
$var reg 3 < ALUop [2:0] $end
$var reg 1 1 Mem_Read $end
$var reg 1 0 Mem_Write $end
$var reg 1 / Mem_to_Reg $end
$var reg 1 . RegWrite $end
$var reg 1 * branch $end
$upscope $end
$scope module DM $end
$var wire 32 = Endereco [31:0] $end
$var wire 1 1 Mem_Read $end
$var wire 1 0 Mem_Write $end
$var wire 1 " clk $end
$var wire 32 > Write_Data [31:0] $end
$var reg 32 ? Read_Data [31:0] $end
$upscope $end
$scope module IG $end
$var wire 32 @ saida_Imm_S [31:0] $end
$var wire 32 A saida_Imm_I [31:0] $end
$var wire 32 B saida_Imm_B [31:0] $end
$var wire 32 C Instrucao [31:0] $end
$var reg 32 D saida_Imm [31:0] $end
$upscope $end
$scope module IM $end
$var wire 32 E Endereco [31:0] $end
$var reg 32 F Instrucao [31:0] $end
$upscope $end
$scope module PC_Reg $end
$var wire 1 " clk $end
$var wire 32 G pc_next [31:0] $end
$var wire 1 # reset $end
$var reg 32 H pc [31:0] $end
$upscope $end
$scope module RF $end
$var wire 1 . RegWrite $end
$var wire 32 I Register1 [31:0] $end
$var wire 32 J Register2 [31:0] $end
$var wire 32 K Write_Data [31:0] $end
$var wire 1 " clk $end
$var wire 5 L rd [4:0] $end
$var wire 1 # reset $end
$var wire 5 M rs1 [4:0] $end
$var wire 5 N rs2 [4:0] $end
$var integer 32 O i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 O
b1011 N
b0 M
b111 L
b1011 K
b0 J
b0 I
b0 H
b1 G
b101100000000001110010011 F
b0 E
b1011 D
b101100000000001110010011 C
b100000000110 B
b1011 A
b111 @
b0 ?
b0 >
b1011 =
b10 <
b10011 ;
b0 :
b0 9
b1011 8
b10 7
b0 6
b1011 5
14
b10 3
b101100000000001110010011 2
01
00
0/
1.
b0 -
b0 ,
b1011 +
0*
b0 )
b0 (
b1 '
b1011 &
0%
b0 $
1#
0"
b0 !
$end
#5
b100000 O
1"
#10
0"
0#
#15
b1 +
b1 8
b1 =
b10 K
b10 )
b10 ?
b1 5
b1 &
b1 D
1/
11
14
1.
b10 3
b10 7
b10 <
b100000000000 B
b1 @
b1 A
b1 L
b1 N
b11 ;
b10 '
b10 G
b100000000000010000011 2
b100000000000010000011 C
b100000000000010000011 F
b1 !
b1 $
b1 (
b1 E
b1 H
1"
#20
0"
#25
b100 K
b10 5
b0 )
b0 ?
b10 &
b10 D
b100 +
b100 8
b100 =
10
0/
14
0.
01
b10 3
b10 7
b10 <
b10 B
b10 @
b10 A
b10 L
b10 N
b10 -
b10 6
b10 I
b1 M
b100011 ;
b11 '
b11 G
b1000001000000100100011 2
b1000001000000100100011 C
b1000001000000100100011 F
b0 ,
b0 >
b0 J
b10 !
b10 $
b10 (
b10 E
b10 H
1"
#30
0"
#35
b10 K
b10 +
b10 8
b10 =
1.
04
00
b11 3
b11 7
b11 <
b0 5
b110000000010 B
b10000000011 @
b10000000010 A
b11 L
b100000 :
b110011 ;
b0 &
b0 D
b100 '
b100 G
b1000000001000001000000110110011 2
b1000000001000001000000110110011 C
b1000000001000001000000110110011 F
b11 !
b11 $
b11 (
b11 E
b11 H
1"
#40
0"
#45
1%
b0 K
b10 5
b0 +
b0 8
b0 =
1.
b101 3
b101 7
b101 <
b100 B
b100 @
b1 A
b100 L
b10 ,
b10 >
b10 J
b1 N
b0 -
b0 6
b0 I
b10 M
b0 :
b111 9
b101 '
b101 G
b100010111001000110011 2
b100010111001000110011 C
b100010111001000110011 F
b100 !
b100 $
b100 (
b100 E
b100 H
1"
#50
0"
#55
0%
b11 K
b1 5
b11 +
b11 8
b11 =
14
1.
b1 3
b1 7
b1 <
b100000000100 B
b101 @
b101 L
b10 -
b10 6
b10 I
b1 M
b110 9
b10011 ;
b1 &
b1 D
b110 '
b110 G
b100001110001010010011 2
b100001110001010010011 C
b100001110001010010011 F
b101 !
b101 $
b101 (
b101 E
b101 H
1"
#60
0"
#65
1%
b0 K
b0 +
b0 8
b0 =
14
1.
b100 3
b100 7
b100 <
b110 B
b110 @
b110 L
b0 -
b0 6
b0 I
b10 M
b101 9
b111 '
b111 G
b100010101001100010011 2
b100010101001100010011 C
b100010101001100010011 F
b110 !
b110 $
b110 (
b110 E
b110 H
1"
#70
0"
#75
0%
b11111111111111111111111111111110 K
b11111111111111111111111111111110 +
b11111111111111111111111111111110 8
b11111111111111111111111111111110 =
1*
04
0.
b11 3
b11 7
b11 <
b10 5
b100000000000 B
b1 @
b1 L
b0 9
b1100011 ;
b100000000000 &
b100000000000 D
b1000 '
b1000 G
b100010000000011100011 2
b100010000000011100011 C
b100010000000011100011 F
b111 !
b111 $
b111 (
b111 E
b111 H
1"
#80
0"
#85
x%
bx K
bx 5
bx +
bx 8
bx =
0*
b0 3
b0 7
b0 <
bx0 B
bx @
bx A
bx L
bx ,
bx >
bx J
bx N
bx -
bx 6
bx I
bx M
bx :
bx 9
bx ;
b0 &
b0 D
b1001 '
b1001 G
bx 2
bx C
bx F
b1000 !
b1000 $
b1000 (
b1000 E
b1000 H
1"
#90
0"
#95
b1010 '
b1010 G
b1001 !
b1001 $
b1001 (
b1001 E
b1001 H
1"
#100
0"
#105
b1011 '
b1011 G
b1010 !
b1010 $
b1010 (
b1010 E
b1010 H
1"
#110
0"
#115
b1100 '
b1100 G
b1011 !
b1011 $
b1011 (
b1011 E
b1011 H
1"
#120
0"
#125
b1101 '
b1101 G
b1100 !
b1100 $
b1100 (
b1100 E
b1100 H
1"
#130
0"
#135
b1110 '
b1110 G
b1101 !
b1101 $
b1101 (
b1101 E
b1101 H
1"
#140
0"
#145
b1111 '
b1111 G
b1110 !
b1110 $
b1110 (
b1110 E
b1110 H
1"
#150
0"
#155
b10000 '
b10000 G
b1111 !
b1111 $
b1111 (
b1111 E
b1111 H
1"
#160
0"
#165
b10001 '
b10001 G
b10000 !
b10000 $
b10000 (
b10000 E
b10000 H
1"
#170
0"
#175
b10010 '
b10010 G
b10001 !
b10001 $
b10001 (
b10001 E
b10001 H
1"
#180
0"
#185
b10011 '
b10011 G
b10010 !
b10010 $
b10010 (
b10010 E
b10010 H
1"
#190
0"
#195
b10100 '
b10100 G
b10011 !
b10011 $
b10011 (
b10011 E
b10011 H
1"
#200
0"
#205
b10101 '
b10101 G
b10100 !
b10100 $
b10100 (
b10100 E
b10100 H
1"
#210
0"
